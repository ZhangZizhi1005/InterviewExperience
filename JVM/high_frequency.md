# JVM笔记 #

---

[toc]

---

---

## JVM ##

---

### JAVA虚拟机的作用 ###

> - 解释运行字节码程序
> - 消除平台相关性

- JVM 将 JAVA 字节码解释为具体平台的具体指令
- 一般高级语言在不同平台上运行, 至少需要编译成不同目标代码, 而JVM屏蔽了具体平台相关的信息, 使得Java语言编译程序只需要生成在JVM上运行的目标代码(字节码), 就可以在多种平台上不加修改的运行

---

---

## JVM 分区 ##

---

### JVM的内存模型 ###

![img](ref/v2-eed680ab8fb4038468b36847cf6e9675_720w.jpg)



| 名称       | 作用                                                         | 线程私有 |
| ---------- | ------------------------------------------------------------ | -------- |
| 方法区     | 用于保存已经被虚拟机加载的类元信息, 运行时常量信息, 字符串常量信息 | 否       |
| 栈         | 用于线程运行方法<br>        每一个线程创建后都会申请一个自己单独的栈空间<br>        每一个方法调用都会对应一个栈帧, 调用方法的过程就是一个压栈和出栈的过程<br>                栈帧中存储: 方法的局部变量表, 操作数栈, 动态连接, 方法的返回地址 | 是       |
| 本地方法栈 | 在JAVA程序需要与操作系统或者底层硬件交换信息时, 需要调用native方法, 调用本地方法时构建的方法栈 | 是       |
| 程序计数器 | 一块较小的内存空间<br>记录某个线程当前执行指令的位置         | 是       |
| 堆         | 虚拟机启动时创建<br>主要用来存放创建的对象数据               | 否       |

---

### JAVA堆模型 ###

<img src="ref/v2-d1878a336726adbd7a33f877909fdf80_720w.jpg" alt="img" style="zoom:67%;" />

- **新生代 和 老年代**

    - 堆内存主要用来存放运行过程中创建的对象数据, 根据对象存活的时间长短特性, 在逻辑上分为 新生代 和 老年代

        对于JVM而言, 绝大部分对象数据都是短暂存在的, 随方法调用而创建, 方法结束而消亡, 只有少部分对象堆长久的留在JVM内存中

    - 对于新创建堆对象, 我们放在新生代中

    - 只有经历了一定次数GC但是还未被回收的对象, 才会被认为可能长时间存在, 才会被转移到老年代中

        

- **Eden区 和  Survivor区**

    ​	<img src="ref/v2-7c8d60af0215cfc6d5ef92613ed636f1_720w.jpg" alt="img" style="zoom: 50%;" /><img src="ref/v2-e65c384d5bb881517ffa4736c83cff26_720w.jpg" alt="img" style="zoom:50%;" />

    - 为了减少GC后的空间碎片, 我们将新生代 划分为 Eden区 和Survivor区

    - 不划分时, 如图一, 新生代中 未被 GC 的对象会将内存分割为一堆不连续的空间

    - 划分后, 对象只在Eden区出生, 每次GC后, 都会将存活的对象, 从Eden区转移到Survivor区, 再清理Eden区, 这样我们就能得到一片连续的Eden区内存

        

- **S1 和 S2**

    - 同样, 就算Survivor区较小, 但是依然会存在 GC 后空间碎片的问题, 因此, 将Survivor区划分为S1 和 S2 两个部分
    - 例如, 我们把Eden S1 S2 的大小设置为 8 : 1 : 1
        - 对象在Eden中出生; 第一次GC,幸存者转移到S1, 清理Eden ,此时 S2 为空
        - Eden中再次产生新的对象, 第二次GC 将Eden区中幸存的对象和S1中的对象 转移到S2中, 清理Eden和S1, 对调From 和 To 的逻辑关系
    - 保证每次使用Survivor区时候, 都有一片连续的空白区域可供使用
    - *代价*
        - 复制对象的开销
        - 10%的空间浪费

---

---

## GC ##

---

### 什么是GC, 为什么要有GC, 能否主动GC ##

- GC 是 垃圾回收, 指回收程序中不再使用的内存

    

- 在程序设计过程中, 内存处理是复杂且重要的, 遗忘或者错误进行内存回收会导致程序或者系统的不稳定甚至崩溃

    JAVA 提供的垃圾回收机制 可以自动检测对象是否超出作用域 从而实现自动回收的目的

    GC使得Java开发人员摆脱了繁琐的内存管理工作，让程序的开发更有效率

    

- JAVA不支持显式的释放某个对象的内存, 只有在虚拟机空闲或者当前内存不足的情况下, 才会触发执行

    编程人员可以手动执行```System.gc()```, 但是JAVA语言规范只保证虚拟机接到这一通知, 不保证GC一定会执行

---

### 常见的GC算法有哪些 ###

> 常见的GC算法有两大类, 一类是Reference Counting GC(引用计数GC), 另一类是Tracing GC(追踪式GC)
>
> 在一部分文献中, 这两类算法也被分别称为 直接GC 和 间接GC
>
> 主流的JVM 一般不采用 引用计数GC, 所以下面简单谈一下, 主要谈 Tracing GC



**直接GC**

- 基本算法 :
    -  在对象中添加一个引用计数器,
    -  每有一个地方引用了这个对象时, 计数器加一; 引用失效时, 计数器减一
    - 计数器归零时, 我们认为这个对象不会再被引用
- 缺陷:
    - 单纯的引用计数算法, 无法解决对象之间循环引用的问题, 必须配合大量的额外处理



**间接GC **

两个基础：

- [可达性分析算法]() : 判断哪些对象需要回收

- 分代收集理论：

  - 代：存放对象的不同区域

  1. 弱分代假说：绝大多数对象都是朝生夕灭的
  2. 强分代假说：熬过越多次GC的对象就越难以消亡
  3. 跨代引用假说：跨代引用相对于同代引用来说仅仅占绝少数

  - 假说1、2奠定了基本的收集器原则：收集器应该将JAVA堆分为不同区域，然后将回收对象依据其不同年龄（熬过GC过程的次数）分配到不同区域之间存储，然后采用不同的算法进行回收
  - 假说3说明了只需要在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，RememberedSet），这个结构将老年代划分为若干个小块，标识出老年代中哪一块内存会进行跨代引用



三种算法：

- 第一步：**标记**
  - 三种算法的第一步都是根据可达性分析算法，标记出所有需要回收的对象
- 第二步：
  1. 算法一：标记-清除算法
     - 统一回收所有被标记的对象，或者如果标记的是无需回收的对象则统一回收所有未被标记的对象
     - 缺陷：
       - 执行效率不稳定：如果JAVA堆中包含大量需要回收的对象，这时标记和清除的效率都会随对象数量增长而降低
       - 内存空间的碎片化：仅仅清除之后会产生大量的不连续的内存碎片，空间碎片太多可能导致需要分配较大对象的时候无法找到连续内存而不得不提前进行下一次GC
  2. 算法二：标记-复制算法
     - 将内存划分为等大小的两块
       - 每次只使用其中一块
       - 当这一块已经用完的时候，将所有被标记或者未被标记死亡的对象复制到另外一块上
       - 清理这一整块内存
     - 优点：
       - 每次都针对半个内存区域进行回收，不需要考虑碎片问题，只需要按顺序移动堆顶指针即可
     - 缺点：
       - 复制在对象存活较多的情况下开销很大
       - 浪费了50%的空间
     - 备注：
       - 一般用来回收新生代
       - 可以采用8:1来分配Eden区和Survivor区，不一定按照1:1
  3. 算法三：标记-整理算法
     - 根据标记，将所有存活的对象都像着同一端移动，然后直接清理最后一个存活对象以后的内存
     - 缺点：
       - 移动存活对象不仅需要大量的开销，而且必须全部暂停用户应用程序（Stop the world）
     - 备注：
       - 折中办法：多数时间采用标记-清除算法，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法



---

### JVM如何判断对象需要回收 ##

> 基本思想：可达性分析（Reference Analysis）
>
> ​	通过一系列称为“GC ROOT”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链（Reference Chain）。
>
> ​	如果某个对象到GC ROOTs之间没有任何引用链相连，或者称为不可达，那么这个对象不可能被使用



---

### JVM中, 什么可以作为GC ROOT ###

在JVM中，固定可作为GC ROOT的对象包括：

-

---

### 常见的GC收集器有哪些? ###

---

---

## 类加载 ##

---

### 简单介绍JVM的类加载机制 ###

