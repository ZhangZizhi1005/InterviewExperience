# 并发

---

[toc]

---

## 零、进程与线程 ##

> 多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述这样执行的程序呢？因此引入了“进程”。

### 进程（Process） ##

#### 定义 ####

进程是具有独立功能的程序关于**某个数据集合上**的**一次运行活动**，是系统进行资源分配的独立单位。若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位。

#### 特点 ####

- 进程是程序的一次执行过程。如果程序执行多次，则需要两个或者多个进程。
- 进程是正在运行的程序的抽象。它代表运行的CPU，因此也可以看作是对CPU的抽象。
- 系统资源（如内存、文件等）以进程为单位进行分配
- 操作系统为每个进程分配了独立的地址空间
- 操作系统通过“调度”将控制权交给进程



---



## 一、什么是线程 ##

补充后和零合并

---

## 二、线程状态 ##

> 线程共有以下六种状态。要确定一个线程的当前状态，可以通过调用getState方法
>
> - New（新建）
> - Runnable（可运行）
> - Blocked（阻塞）
> - Waiting（等待）
> - Timed Waiting（计时等待）
> - Terminated（终止）

### 1、新建 ##

​	当用new操作符创建了一个新线程时（例如```new Thread(r)```），这个线程不会运行，此时其状态为 *new（新建）*

### 2、可运行 ###

- 一旦调用了```start```方法，线程就转变为 *Runnable（可运行）* 状态 
- 在任意给定的时刻，一个处于 *Runnable（可运行）* 状态的线程，可能在运行也可能不在运行
    - 一个线程开始运行后不一定保持运行，需要暂停让其他线程有机会运行

### 3、阻塞、等待和计时等待

> 当线程处于这三种状态时，它暂时不活动（即线程对应的代码不运行），此时依赖于线程调度器重新激活这一线程
>
> 值得注意的是，激活后线程处于 *可运行* 状态，但是不一定会运行，需要检查线程与当前运行线程的优先级

<img src=".\ref\线程状态" alt="image-20210225223951766" style="zoom: 50%;" />

### 4、终止 ###

​	线程会由于以下两个原因之一终止

- ```run```方法正常退出，程序自然终止
- 因为一个没有捕获的异常终止了```run```方法，线程意外终止

---

## 三、线程属性 ##

### 1、中断线程 ###

- 任何线程都会有一个```boolean```标志，来记录线程是否中断

    1. 调用静态的```Thread.currentThread```方法获取当前线程

    2. 对当前线程调用```interrupt```方法，会设置当前线程的 *中断状态* ，也就是其```boolean```标志

    3. 对当前线程调用```isInterrupted```方法，返回线程的```boolean```标志

        > 对比：
        >
        > ```interrupt```方法是一个静态方法，调用这一方法会清除线程的中断状态
        >
        > ```isIterrupted```方法是一个实例方法，调用这一方法不会改变中断状态

- 中断一个线程不是要终止这一线程，而是需要引起其注意，被中断的线程可以决定如何响应中断

- 如果线程被阻塞（以下如无特殊说明，统称阻塞、等待、计时等待为阻塞状态），此时无法检查中断状态

    - 如果对一个阻塞线程调用```isInterrupted```方法，会抛出一个```InterruptedException```异常，这可能引起线程中断

### 2、守护线程 ###

> 通过调用```t.setDaemon(true)```方法，可以将线程转换为守护线程

- 守护线程的唯一用途是为其他线程提供服务
- 当只剩下守护线程的时候，虚拟机会自动退出
- 守护线程必须在线程启动之前被标识

### 3、线程名 ###

> 通过调用```t.setName("threadname")```方法，为线程赋予名字

### 4、未被捕获的异常处理器 ###

> 稍后补充

### 5、优先级 ###

> 已废弃，现映射到操作系统优先级

- Windows 7个优先级别
- Linux 所有线程具有相同的优先级

---

## 四、同步 ##

### 1、竞态条件 ###

> 两个线程存取同一个对象，并且每个线程分别调用了一个修改该对象状态的方法，会导致相互覆盖，具体结果取决于线程访问数据的顺序。

### 2、竞态条件详解 ###

1. 一个线程内的操作越多，越有可能出现竞态
2. 一个线程内对修改对象状态间的间隔越久，越有可能出现竞态

### 3、锁对象 ###

> 为了防止并发的访问代码块，有两种解决办法
>
> 1. ```synchronized```关键字
> 2. ```ReentrantLock```类（Java 5 以后）
>
> 本节主要介绍```ReentrantLock```类，下节介绍```synchronized```关键字

*用```Reentrant```类保护代码块的基本结构如下：*

```java
public class classname{
    private var myLock = new ReetrantLock();//
    ...
    public void methodName(){
        myLock.lock(); // a Reetrant object
        try{
            //critical section
   		}
    	finally{
       		myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown
    	}
    }
}
```

1. 在类中构造一个```ReentrantLock```类型的对象，即构造一把锁
2. 在某段代码块前调用```锁.lock()```方法，在这段代码块的```finally``` 子句中调用```锁.unlock()```方法
    - 假设一个线程调用了这个方法，那么这个线程在执行过程中就拥有了这把锁，直到方法执行完毕才会释放这把锁
    - 如果在这个过程中有另外一个线程试图调用这个方法，那么第二个线程在调用lock方法的过程中因为这把锁没有被释放所以阻塞

*关于```ReentrantLock```类还存在如下的两个特殊点：*

- 上面这个声明了锁的类中，每个对象都有自己的锁对象，这意味着如果两个线程访问的不是同一个对象，那么就不会阻塞
- 由这个类构造的锁成为可重入锁
  - 线程可以反复获得已经拥有的可重入锁
  - 即线程可以在获得一把锁的情况下，调用由这把锁锁住的其他方法
  - 获得锁的数量由锁内部的计数器记录

*公平锁