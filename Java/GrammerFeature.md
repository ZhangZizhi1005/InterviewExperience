[toc]

---

---

## Java基础 ##

---

### equals方法和 == 的区别？ ###

-   == 比较的是

    - 在（栈）内存的变量 *引用* 对象的（堆）内存地址，用来判断是否是同一引用
    - 或者是，八种基本类型的值是否相等

- equals用来比较的是两个对象的内容是否相等。

    - 如果没有对该方法进行重写的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。
    - 通常情况下，我们会根据类的实际需要，对equals方法进行重写。

    ```java
    //以String类为例，进行展示
    String s1 = "Monday";
    String s2 = "Monday";
    String s3 = new String("Monday");
    String s4 = s3.intern(); 
    // 用==判断时，1、2、4相等,引用都在字符串缓冲池中
    // 用equals判断时，全部相等
    ```

    

---

### 为什么重写了equals方法还要重写hashcode方法？ ###

- Object类中的这两个方法：

    - hashcode：返回对象地址的hash值

    - equals：返回==的结果

        > 两者在比较 *值相同但引用不同* 的情况下是均不能返回符合hashmap要求的结果

- HashMap为什么采用两个比较：

    - 重写的equals方法一般较为复杂，如果所有的比较全部用这种方法，尽管可靠，但是效率太低

    - 重写的hashcode方法可以返回对象的hash值，但是由于hash算法的特点，实现简单，但是不同的对象在特定情况下可能具有相同的hash值

        > 所以对于大量的比较，首先采用hashcode方法，对hash值相同的对象再采用equals方法即可。

---

### 什么是Map，常见的Map有哪些？ ###

> Map是一种用于**存储键值对**的数据结构，可以根据键得到值
>
> 所以不允许重复的键，但是允许重复的值
>
> Java为其定义了一个接口```java.util.Map```，常见的实现类有以下几种

- HashMap：根据键的Hash值存储数据

    - 特点：

        - O（1）的访问时间
        - 遍历时取得顺序随机

    - 限制：

        - 最多允许一条记录键为NULL

        - 不支持线程的同步，但可以通过以下方法解决：

            - 使用```Collections```中的synchronizedMap方法使得HashMap具有同步能力
            - 使用ConcurrentHashMap类

            

- HashTable：继承自Dictionary类

    - 特点：同上

    - 限制

        - 不允许键为NULL
        - 支持线程同步，同一时刻只能由一个线程写入，可能导致某些情况下写入较慢

        

- LinkedHashMap：HashMap的一个子类，保存了记录的插入顺序

    - 特点：

        - O（1）的访问时间
        - 使用迭代器遍历时，得到的记录按照插入顺序排列
        - 遍历速度较慢，除非数据量很少但是HashMap的容量很大，否则一般来说慢于HashMap的遍历

        

- TreeMap：实现了SortMap接口，按照键的顺序保存记录

    - 特点：
        - 同HashMap
        - 使用迭代器遍历时，得到记录按照键的顺序排列

---

### Lambda表达式的优、缺点？ ###



优点： 

- 代码简洁，节省了大量的匿名内部类
- 方便函数式编程 
- 容易进行并行计算 
- 改善了集合操作（引入Stream API） 

  缺点： 

- 代码可读性变差 
- 使得语言学习曲线陡峭，学习难度提升 
- 性能方面，在非并行计算中，很多计算未必有传统的for性能要高 
- 不容易进行调试

---

### 十进制数在内存中的存储形式？ ###

二进制补码的形式存储