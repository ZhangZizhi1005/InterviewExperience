[toc]

---

---

## Java基础 ##

---

### equals方法和 == 的区别？ ###

-   == 比较的是

    - 在（栈）内存的变量 *引用* 对象的（堆）内存地址，用来判断是否是同一引用
    - 或者是，八种基本类型的值是否相等

- equals用来比较的是两个对象的内容是否相等。

    - 如果没有对该方法进行重写的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。
    - 通常情况下，我们会根据类的实际需要，对equals方法进行重写。

    ```java
    //以String类为例，进行展示
    String s1 = "Monday";
    String s2 = "Monday";
    String s3 = new String("Monday");
    String s4 = s3.intern(); 
    // 用==判断时，1、2、4相等,引用都在字符串缓冲池中
    // 用equals判断时，全部相等
    ```

    

---

### 为什么重写了equals方法还要重写hashcode方法？ ###

- Object类中的这两个方法：

    - hashcode：返回对象地址的hash值

    - equals：返回==的结果

        > 两者在比较 *值相同但引用不同* 的情况下是均不能返回符合hashmap要求的结果

- HashMap为什么采用两个比较：

    - 重写的equals方法一般较为复杂，如果所有的比较全部用这种方法，尽管可靠，但是效率太低

    - 重写的hashcode方法可以返回对象的hash值，但是由于hash算法的特点，实现简单，但是不同的对象在特定情况下可能具有相同的hash值

        > 所以对于大量的比较，首先采用hashcode方法，对hash值相同的对象再采用equals方法即可。

---

### 什么是Map，常见的Map有哪些？ ###

> Map是一种用于**存储键值对**的数据结构，可以根据键得到值
>
> 所以不允许重复的键，但是允许重复的值
>
> Java为其定义了一个接口```java.util.Map```，常见的实现类有以下几种

- HashMap：根据键的Hash值存储数据

    - 特点：

        - O（1）的访问时间
        - 遍历时取得顺序随机

    - 限制：

        - 最多允许一条记录键为NULL

        - 不支持线程的同步，但可以通过以下方法解决：

            - 使用```Collections```中的synchronizedMap方法使得HashMap具有同步能力
            - 使用ConcurrentHashMap类

            

- HashTable：继承自Dictionary类

    - 特点：同上

    - 限制

        - 不允许键为NULL
        - 支持线程同步，同一时刻只能由一个线程写入，可能导致某些情况下写入较慢

        

- LinkedHashMap：HashMap的一个子类，保存了记录的插入顺序

    - 特点：

        - O（1）的访问时间
        - 使用迭代器遍历时，得到的记录按照插入顺序排列
        - 遍历速度较慢，除非数据量很少但是HashMap的容量很大，否则一般来说慢于HashMap的遍历

        

- TreeMap：实现了SortMap接口，按照键的顺序保存记录

    - 特点：
        - 同HashMap
        - 使用迭代器遍历时，得到记录按照键的顺序排列

---

### Lambda表达式的优、缺点？ ###

优点： 

- 代码简洁，节省了大量的匿名内部类
- 方便函数式编程 
- 容易进行并行计算 
- 改善了集合操作（引入Stream API） 

  缺点： 

- 代码可读性变差 
- 使得语言学习曲线陡峭，学习难度提升 
- 性能方面，在非并行计算中，很多计算未必有传统的for性能要高 
- 不容易进行调试

---

### Java支持的数据类型有哪些？ 什么是自动拆装箱 ###

​	Java 支持八种基本数据类型

| 名称    | 长度（字节） | 表示                                                         |      |
| ------- | ------------ | ------------------------------------------------------------ | ---- |
| byte    | 1            | -2<sup>8</sup> ~ 2<sup>8</sup>-1        (127)                |      |
| short   | 2            | -2<sup>16</sup> ~ 2<sup>16</sup>-1      (32k~33k)            |      |
| int     | 4            | -2<sup>32</sup> ~ 2<sup>32</sup>-1      (2147483647, 20亿+，不超过10的9次方放心使用) |      |
| long    | 8            | -2<sup>64</sup> ~ 2<sup>64</sup>-1    （9 223 372 036 854 775 808， 略小于10的19次方） |      |
| float   | 4            |                                                              |      |
| double  | 8            |                                                              |      |
| char    | 8            |                                                              |      |
| boolean | 1            |                                                              |      |

​	Java为所有的基本数据类型提供了对应的包装类，自动拆装箱是对根据使用的需求，自动的将基本类型和其包装类进行转化的过程

---

### 什么是值传递，什么是引用传递 ###

- call by value: 方法接受的是调用者提供的值
- call by reference: 方法接受的是调用者提供的变量地址

> Java总是采用按值调用, 也就是方法得到的是所有参数的一个副本
>
> 所以:
>
> - 方法不能修改基本数据类型的参数
> - 方法不能让一个对象参数引用新的对象
> - 方法可以修改对象参数的状态



---

### 数组 和 ArrayList有什么区别 ###

| 数组                               | ArrayList                                            |
| ---------------------------------- | ---------------------------------------------------- |
| 可以包含基本类型或者是对象类型     | 只能包含对象类型                                     |
| 大小是固定的                       | 可以动态扩容                                         |
|                                    | 提供了更多的方法特性, 包括继承自集合或者迭代器的方法 |
| 处理固定大小的基本数据类型较为方便 |                                                      |

---

### String, StringBuffer 和 StringBuilder类的联系和区别 ###

<img src="ref/20180411092328691" alt="img" style="zoom: 80%;" />

- String类是一个被final关键字修饰的类, 这意味着String类对象的值是不能被改变的, 对String的操作是指向新的对象而不是改变当前对象的状态, 大量的对String对象进行操作可能会导致有限的内存空间被浪费, 程序运行效率低下
- StringBuilder类是一个继承自AbstractStringBuilder抽象类的可变类, 每个StringBuilder类对象都有一定的缓冲区容量, 当字符串大小超出容量后, 会自动扩容, 所以对其指向的字符串进行操作不会产生新的对象
- StringBuffer类也是一个继承自AbstractStringBuilder抽象类的可变类,基本功能类似于StringBuilder类,主要的区别在于使用Synchronized关键字对方法进行了修饰, 损失了一定的运行效率但是实现了线程安全
    - 例如 两者的Append方法都是调用了super.Append()方法, 实现上是一直的, 但是Buffer用Synchronized关键字修饰了这个方法

---

### & 与 && 的区别 ###

- & : 逻辑与 位运算符按位与

- && : 短路与
- 逻辑与 和 短路与: 
    - 两边同时为真才为真
    - 逻辑与两边都要判断
    - 短路有前边为假, 就不会判断后面

---

### 什么是正则表达式, Java如何处理正则表达式 ###

​	正则表达式(Regular Expression) : 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

​	Java 为String类提供了支持正则表达式的一系列操作方法, 包括matches(), replaceAll(), split()等等

​	Java 在Java.util.regex包内提供了一系列类(例如Patter类,Matcher类等),  用来表达或者处理正则表达式