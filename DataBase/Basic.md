# 数据库 #

---

[toc]

---

---

## 数据库基础 ##

---

### 数据库的三范式 ###

[参考资料](https://www.zhihu.com/question/24696366)

​	**范式** 来自英文 *Normal Form*， 简称NF，指应当满足的约束条件

​	目前数据库的范式有六种，随着级别的增高要求逐步的严苛。一般来说，我们设计数据库需要满足前三个基本的范式：

1. **第一范式**

    在关系模型中，所有的域都应该是原子性的

    - 即，数据库列表中的每一列都应该是不可分割的原子项，而不能是集合、数组等非原子数据项
    - 即，实体中的某个属性由多个值域构成时，必须拆分为不同的属性

    第一范式保证了列表中不存在重复的域

2. **第二范式**

    在1NF的基础上，消除了非主属性对于候选码（简称：码）的部分函数依赖，使所有非主属性完全函数依赖于码

3. **第三范式*

    在2NF的基础上，消除了非主属性对于码的函数传递依赖

---

### 数据库的切分 ###

- 垂直切分：将原来的一个表按列拆分到两个或者多个表中，通过主键来关联；或者是按照业务将表进行分类，分布到不同的数据库上面
    - 优点
        1. 拆分后业务清晰，拆分规则明确
        2. 系统之间整合或者扩展容易
        3. 数据维护简单
    - 缺点
        1. 部分业务表join无法在数据库级别完成，需要借助程序接口
        2. 单表大数据量仍然存在性能瓶颈
        3. 事务处理相对复杂
        4. 切法到达一定程度后，扩展性会遇到限制
- 水平切分：按照某个字段的某种规则，将数据切分到多张数据表
    - 优点
        1. 解决单表大数据量的性能瓶颈问题
        2. 应用端改造较小
        3. 事务处理相对简单
    - 缺点
        1. 切分规则相对较为复杂，难以抽象出一个满足整个数据库的切分规则
        2. 后期数据维护难度增加，人为手工定位数据更困难
        3. 应用系统模块耦合度增高，可能会对后期迁移拆分造成一定困难

---

### 什么是数据库索引？ ###

​	数据库索引是数据库管理系统中一个排序的数据结构，通过增加额外的写操作和存储空间来维护数据库索引，可以提高从数据库中读取数据的速度。

​	可以将数据库索引看作是为了提高表的搜索效率而对某些字段中的值建立的目录。

- **Clustered Index & Non-Clustered Index**
    - 聚集索引：指数据库表行中数据的物理顺序和键值的逻辑顺序（也就是索引顺序）相同
        - 一个表只能由一个聚集索引
        - 聚集索引比非聚集索引具有更快的检索速度
        - 最好在创建表的时候添加聚焦索引，否则由于其顺序的特殊性，后续添加开销非常大
    - 非聚集索引：指数据库表行中数据的物理顺序和键值的逻辑顺序（也就是索引顺序）不同，以主键以外的值构建的索引
        - 一个表可以有多个非聚集索引
        - 非聚集索引可以在逻辑上为数据排序
        - 用树形式实现时，叶节点不包含数据，而是指向数据的指针
        - 如果查询非聚焦索引列中不包含的列，需要回表进行二次查询，时间开销较大
            - 可以构建符合索引
            - SQL Server支持include用法

---

### 索引的底层实现 ###

数据库的索引一般来说采用B+树来实现，也可以采用B树或者Hash来实现。

B+树是一刻m阶（高度）为m的平衡N叉树，它具有如下特点：

- 每个节点个数不能超过N，否则会造成分裂；也不能小于N/2，否则会造成合并
- 根节点的个数可以不超过N/2，但根节点至少有两个子女
- 非叶子节点只储存关键字，有k个子女则必须有k个关键字
- 只有叶子节点储存数据

作为数据库索引时，有如下变形

- 所有非叶子节点中存储的关键字都是可能的索引取值
- 叶子节点存储一个元组的数据或者指向的指针
- 叶子节点之间通过双链表串联，方便查找

---

### 索引的失效 ###

1. 未遵循最左匹配原则
2. like查询以%开头
3. 隐式类型转换
4. 对索引内部应用函数

---

### 什么是数据库的事务，事务的ACID特性是什么？ ###

**数据库事务(Database Transaction):** 是指 访问数据库 并 可能操作各个数据项的一个操作序列， 这个操作序列由特定的事务开始语句和事务结束语句包裹。

事务的 *ACID* 特性：

1. **Automatically（原子性）：** 一个事务中的操作，要么全都执行，要么全都不执行
2. **Consistency（一致性）：** 几个 *并行执行* 的事务，执行的结果 必须与 按照某一 *串行* 顺序执行 得到的结果一致
3. **Isolated（隔离性）：** 事务的执行不会受到其他事务的干扰，事务执行的中间结果对其他事务时透明的
4. **Durability（持久性）：** 对任意已经提交的事务，系统必须保证事务对该数据库的操作结果不丢失

DBMS采用日志来保证事务的 ACD，采用锁机制来保证事务的I

---

### 数据库的事务隔离级别 ###

| 隔离级别/问题是否能避免      | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--------------------------- | ------------------ | -------------------------------- | -------------------- |
| 未提交读（Read Uncommitted） |                    |                                  |                      |
| 已提交读（Read Commited）    | √                  |                                  |                      |
| 可重复读（Repeatable Read）  | √                  | √                                |                      |
| 可串行化（Serializable）     | √                  | √                                | √                    |

- 问题：

    - 脏读：一个事务处理过程中 读取到 另外一个 *未提交的事务* 中的数据

        ```sql
        -- 账户A（200块） 向 账户B（200块） 中转入100块 
        update account set money=money+100 where name='B'
        /*
        此时执行 账户B为300块
        select money from account where name='B'
        */
        update account set money=money-100 where name='A'
        -- 如果该事务未提交，操作将回滚，此时执行账户B为200块
        select money from account where name='B'
        ```

    - 不可重复读：对于某个数据，一个事务范围内多次查询却返回了不同的结果

        - 例如事务T1读取某个数据后，事务T2修改了这个数据并提交，此时事务T1再次读取就会返回不同的结果
        - 脏读时读取了另一个事务未提交的数据，不可重复读是读取了另一个事务已经提交的数据

    - 幻读：对于某一批数据，一个事务读取了另一个事务提交的修改

        - 幻读和不可重复读都是读取了另一个已经提交的事务的修改
        - 不可重复读指同一数据项不能重复读取，幻读指这批数据项和上次读取不同

- 隔离级别（由低到高）

    - Read Uncommitted：能读取所有数据，可能发生所有问题
    - Read Committed：只能读取已经提交的数据，不会发生脏读，Oracle等多数数据库默认级别
    - Repeatable Read：同一个事务内的查询都是事务开始时刻一致进行，不会发生脏读和不可重复读，InnoDB默认级别
    - Serializable：完全串行化的读，每次读都需要获取表级共享锁，可以避免以上所有情况但是效率最低

---

---

## MySQL基础 ##

---

### InnoDB 和 MyISAM 的取舍？ ###

InnoDB 和 MyISAM具有如下**区别**：

1. 索引
    - InnoDB采用聚焦索引，其主键索引的叶子节点就是数据文件，辅助索引的叶子节点时主键的值
    - MyISAM采用的时非聚焦索引，叶子节点存储的是数据文件的地址
2. 唯一索引
    - InnoDB必须要有唯一索引（一般是主键，如果未指定会自动生成一列Row_id来充当默认主键）
    - MyISAM可以没有主键
3. 事务
    - InnoDB支持事务。InnoDB默认将每一条SQL语句封装为事务，自动提交，会影响速度；可以通过手动封装事务改善
    - MyISAM不支持事务
4. 锁
    - InnoDB默认支持行级锁。但是这个行锁实现在索引上，而非物理记录上，所以访问未命中索引的情况下，会退化未表锁
    - MyISAM支持表级锁
5. 外键
    - InnoDB支持外键
    - MyISAM不支持外键，I表转M表有可能失败
6. 行数
    - InnoDB不保存具体行数（由于其事务特性，针对不同事务行数可能不相同），所以统计行数需要全表扫描
    - MyISAM用一个变量保存了整个表的行数
7. 全文索引
    - InnoDB在MySQL 5.7以前不支持
    - MyISAM支持全文索引，所以可以利用全文索引进行查询的领域效率更高

InnoDB和MyISAM的**选择：**

- 是否要支持事务，如果需要，选择InnoDB
- 是否绝大多数操作都是只读，如果是，可以考虑MyISAM
- MySQL5.5后默认引擎由M变成了I，即大多数情况下可以使用I

---

